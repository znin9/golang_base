package main

/*
*
一维数组的DP

问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

解体思路:

	1.定义数组的含义: 假设dp[i]的值表示跳上i级台阶的公共方式
	2.找出数组元素之间的关系: 这个是动态规划算法的核心也是最难的。在这里要求解跳上第n级台阶的方法是dp[n]
							根据这道题的描述跳上第n级台阶可以从n-1处跳1级，也可以从n-2处跳两级。
							而跳到n-1的方法由dp[n-1]种，跳到n-2的方法有dp[n-2]种。所以数组元素之间的关系就是 dp[n]=dp[n-1]+dp[n-2]
	3.找出初始条件:在这里跳上第1级台阶只有1种方法，因此dp[1]=1，跳上2级台阶有两种方法因此dp[2]=2(跳两次和跳一次)
*/
func main() {

}

// jump
func jump(n int) int {
	dp := make([]int, n+1)
	dp[1] = 1
	dp[2] = 2
	if n == 1 {
		return dp[1]
	}
	if n == 2 {
		return dp[2]
	}
	for i := 3; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return n
}
